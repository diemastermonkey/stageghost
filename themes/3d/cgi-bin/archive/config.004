#!/usr/bin/perl
# Primitive config UI for DronesoundTV/Stageghost
# 20161121 @garyd @diemastermonkey
# Notes
#   %ENV contains other handy info

# Globals
my $sQuery = $ENV{'QUERY_STRING'};
my @CGI = split (/\&/, $sQuery);
my %CGIData, %Config, %Update;
my $sURL = "/cgi-bin/config"; # Path to cgi
my $ConfigPath = "config"; # Subdir
my $Dash = "-" x 64;

# Mandatory http header
print ("Content-type: text/html\n\n");
print ("<!DOCTYPE html>\n");
print ("<head>\n");
fnWebScript();		# Script must go in header
print ("</head>\n");
print ("<body>\n");

# Diag UI
fnWebPrintln ("Using $0");
fnWebPrintln ($Dash);

# Display form
fnWebForm();
fnWebPrintln ($Dash);

# Parse CGI parms
fnWebPrintln ("CGI Data");
fnWebPrintln ($Dash);
foreach $Line (@CGI) {      # Parse CGI into Data hash
  ($Field, $Value) = split (/\=/, $Line);
  $CGIData{$Field} = $Value;
  fnWebPrintln ("$Field=$Value");
}

# Get/display saved config
fnConfigRead();
fnWebPrintln ($Dash);
fnWebPrintln ("Current Configuration");
fnWebPrintln ($Dash);
$ConfigKeys = join (keys (%CGIData), ", ");
# fnWebPrintln ("Query keys: $ConfigKeys");

# Start the select list
fnWebPrintln (
  "<select id='fieldSelect' onChange='fnUpdateValueDisplay();'>"
);  
# Make list option for each key (field name)
foreach $Line (keys(%Config)) {
  if ($sQuery =~ /$Line/i) {
    $Prefix = "*";
  } else {
    $Prefix = "";
  }
  fnWebPrintln ("<option>"
    . $Prefix . $Line         # Just name of field
    . "</option>"
  );
}
fnWebPrintln ("</select>");   # End select list

# Also, hidden fields with the values, named with field name
foreach $Line (keys(%Config)) {
  fnWebPrintln (
    "<input type=\"hidden\" id=$Line value=\""  # Value in hidden field
    . substr($Config{$Line}, 0, 96) 
    . "\">"
  );
}

# Close the HTML!
print ("\n</body></html>");

# Functions
# ----------------------

# Print one line webishly
sub fnWebPrintln {
  print ("\n".shift(@_)."<br>");
}

# Spit out webform
sub fnWebForm {
  $sNewURL = $sURL
    . "?" 
    . $sQuery
    . join (@CGIData, "&");

  # Print until END
  print 
<<END
  Update Form
  <form action="$sNewURL">
    <input type="text" id="field" name="field" value="field">
    <input type="text" id="value" name="value" value="value"
      onChange="fnEditValue();">
    <!-- Store single field/value update till submit   -->
    <input type="hidden" id="updatefield" value="">
    <input type="hidden" id="updatevalue" value="">
    <input type="submit" id="submit" value="Submit">
  </form>
  <br />
  <input type="text" id="uiTextOut" value="(empty)" size="48">
END
}  # End function

# Spit out script for header
sub fnWebScript {
  # Print until END
  print 
<<END
  <script type="text/javascript">
    function fnUpdateValueDisplay () {
      var sField = document.getElementById('fieldSelect').value;
      var sValue = document.getElementById(sField).value;
      document.getElementById('field').value = sField; // Show field 
      document.getElementById('uiTextOut').value = sValue; // Show value 
    }

    // When displayed value edited, update hidden update field
    function fnEditValue () {
      var sField = document.getElementById('fieldSelect').value;
      var sValue = document.getElementById('value').value;
      // Update visually
      document.getElementById('uiTextOut').value = sValue;
      // Update hidden field
      document.getElementById('updatefield').value = sField;
      document.getElementById('updatevalue').value = sValue;
    }
  </script>
END
}

# Get existing config data, brutally
sub fnConfigRead {
  foreach $setting (`find $ConfigPath/ -type f`) {
    $value = `cat $setting`; chomp ($value);
    $setting =~ s/$ConfigPath\///g;  # Remove path
    chomp ($setting);
    $Config{$setting} = $value;
  }
}
